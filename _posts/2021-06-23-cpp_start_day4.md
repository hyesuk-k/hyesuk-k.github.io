---
title:  "씹어먹는 C++ 4일차"
excerpt: 5장 객체지향프로그래밍의 시작

categories:
  - 'cpp'
tags:
  - cpp
  - book

toc: true
toc_sticky: true

date: 2021-06-23
last_modified_at: 2021-06-23

---

❗참고 : <https://modoocode.com/135>

* 절차지향적 언어
  + C, Pascal
  + procedure를 지향하는 언어
  + 프로그램을 설계할 때 중요한 부분을 하나의 함수로 만들어 쪼개서 처리함

+ 객체지향적 언어
  + C++, Java, Python, C# 등
  + 객체 중심?

# 객체란?

* 함수의 인자로 구조체를 넘겨주기 와 변수에 해당하는 함수를 호출하기

* 객체란 변수들과 참고자료들로 구성된 소프트웨어
  + 자신의 상태를 나타내는 변수
  + 자신의 행동을 수행하는 함수

* 추상화(Abstraction)
  + 객체가 현실 세계에 존재하는 것들을 나타내기 위한 방법
  + 변수 및 함수로 추상화

* 인스턴스 변수와 인스턴스 메소드
  + 객체에 정의된 변수와 함수를 의미
  + 클래스를 이용하여 만들어진 객체

* 캡슐화(Encapsulation)
  + 외부에서 인스턴스 변수를 직접 수정하지 않음
  + 인스턴스 변수는 인스턴스 함수를 이용하여 수정
  + 객체가 내부적으로 어떻게 동작하는지 모르더라도 사용할 수 있도록 함

# 클래스

* 객체의 설계도
* 클래스를 이용하여 실제 객체를 생성

```cpp
<Class 이름> <클래스의 인스턴스 명>
```

* 멤버 변수와 멤버 함수
  + 클래스 안에 선언된 변수와 함수
  + 클래스는 인스턴스가 생성되어야 실재함
  + 멤버 변수와 멤버 함수도 인스턴스가 생성되어야 실재

* 클래스와 접근 지시자
  + 접근 지시자는 private, public 등을 의미
  + 클래스 내에서의 변수와 함수는 별도 접근 지시자가 없을 시, 기본으로 private로 설정됨

# 생성자와 함수의 오버로딩

## 함수의 오버로딩

* C언어에서는 하나의 이름을 가지는 함수는 딱 1개

* C++에서는 하나의 이름을 여러 함수가 사용 가능
  + 함수 호출 시 인자를 이용해 함수들을 구별
  + 함수 호출 시, 함수 이름은 동일하더라도 인자가 다르면 다른 함수


```cpp
#include <iostream>

void print (int x) { std::cout << "int: " << x << std::endl; }
void print (double x) { std::cout << "double: " << x << std::endl; }

int main () {
    int a = 1;
    char b = 'c';
    double c = 3.2f;

    print(a);
    print(b);
    print(c);

    return 0;
}
```

* C++ 컴파일러가 함수를 오버로딩 하는 과정
  + 자신과 타입이 정확하게 일치하는 함수를 찾는다
  + 정확하게 일치하는 함수가 없는 경우, 형변환을 통해 일치하는 함수를 찾는다
  + 포괄적인 형변환 수행 후 일치하는 함수를 찾는다
  + 유저 정의된 타입 변환으로 일치하는 함수를 찾는다

## 생성자

* 객체 생성 시 자동으로 호출되는 함수
* 객체를 생성 후 바로 초기화

### Default Constructuor

* 생성자를 별도로 정의하지 않더라도 호출됨
